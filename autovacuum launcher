postgres: autovacuum launcher

	- clear dead records
	- analyze tables (gather statistics)
	- Helps you avoid wraparound problem (Freezing old txid)

DEAD TUPLE
-----------

autovacuum_work_mem = -1               
log_autovacuum_min_duration = 10min    
autovacuum = on                        
autovacuum_worker_slots = 16    
autovacuum_max_workers = 3  
autovacuum_naptime = 1min             

autovacuum_vacuum_threshold = 50  
autovacuum_vacuum_scale_factor = 0.2 

1000 records

vacuum threshold => 50+ 0.2*no.of records
				 => 50+0.2*1000
				 => 50+200 => 250
     
autovacuum_analyze_threshold = 50   
autovacuum_analyze_scale_factor = 0.1  

				=> 50+0.1*100
				=> 50+100 =>150
					
   
autovacuum_vacuum_insert_threshold = 1000  
autovacuum_vacuum_insert_scale_factor = 0.2 
   
autovacuum_vacuum_max_threshold
autovacuum_freeze_max_age = 200000000     (200 million) 


Reasons for freeze not happening?
================================
1. long running queries (98%)
2. long running queries in replica (1%)
3. setup replication but replica is not in sync (1%)
4. prepared statements

How to check
--------------
WITH max_age AS (
    SELECT 2000000000 as max_old_xid
        , setting AS autovacuum_freeze_max_age
        FROM pg_catalog.pg_settings
        WHERE name = 'autovacuum_freeze_max_age' )
, per_database_stats AS (
    SELECT datname
        , m.max_old_xid::int
        , m.autovacuum_freeze_max_age::int
        , age(d.datfrozenxid) AS oldest_current_xid
    FROM pg_catalog.pg_database d
    JOIN max_age m ON (true)
    WHERE d.datallowconn )
SELECT max(oldest_current_xid) AS oldest_current_xid
    , max(ROUND(100*(oldest_current_xid/max_old_xid::float))) AS percent_towards_wraparound
    , max(ROUND(100*(oldest_current_xid/autovacuum_freeze_max_age::float))) AS percent_towards_emergency_autovac
FROM per_database_stats


autovacuum_vacuum_cost_delay = 2ms                                           
autovacuum_vacuum_cost_limit = -1     or 200 

#autovacuum_vacuum_cost_limit = -1      # default vacuum cost limit for
                                        # autovacuum, -1 means use
                                        # vacuum_cost_limit



Few commands
-------------
postgres=#
postgres=# vacuum emp;
VACUUM
postgres=# analyze emp;
ANALYZE
postgres=#
postgres=# vacuum analyze emp;
VACUUM
postgres=# vacuum freeze emp;
VACUUM
postgres=# vacuum (analyze, freeze) emp;
VACUUM
postgres=# vacuum full emp;   #CREATE TABLE AS SELECT; ACQUIRES LOCK
VACUUM
postgres=# vacuum (INDEX_CLEANUP OFF) emp;
VACUUM

- next thing you do is reindex

postgres=# reindex index pgbench_accounts_pkey;
REINDEX
postgres=#
[or]
postgres=# reindex table pgbench_accounts;
REINDEX
postgres=#
postgres=# analyze;
ANALYZE
postgres=#
postgres=# vacuum;
VACUUM
postgres=#



Vacuum best practices
---------------------

1. schedule a manual vacuum (every night)
2. Disable autovacuum on any table or adjust threshold limits on any table
https://www.cybertec-postgresql.com/en/enabling-and-disabling-autovacuum-in-postgresql/

ALTER TABLE t_foo 
     SET (autovacuum_vacuum_scale_factor = 0.4);
ALTER TABLE

ALTER TABLE t_foo 
     SET (autovacuum_enabled = false);
ALTER TABLE

3. If you disable autovacuum on a table, ensure that you have manual vacuum job in place
4. TxID utilization -> keep an eye on it (50%-70% is the max that you should see) 
5. adjust autovacuum_vacuum_cost_delay & autovacuum_vacuum_cost_limit to make vacuum fast
6. maintanance_work_mem -> increase this to make vacuum faster
7. periodically do vacuum full on business critical tables. (10%-20% -> is the best practice)


      View "pg_catalog.pg_statio_user_indexes"
    Column     |  Type  | Collation | Nullable | Default
---------------+--------+-----------+----------+---------
 relid         | oid    |           |          |
 indexrelid    | oid    |           |          |
 schemaname    | name   |           |          |
 relname       | name   |           |          |
 indexrelname  | name   |           |          |
 idx_blks_read | bigint |           |          |
 idx_blks_hit  | bigint |           |   
 

postgres=# insert into emp values(1,1);
ERROR:  database is not accepting commands that assign new transaction IDs to avoid wraparound data loss in database "template1"
HINT:  Execute a database-wide VACUUM in that database.
You might also need to commit or roll back old prepared transactions, or drop stale replication slots.
postgres=# 
                                        



